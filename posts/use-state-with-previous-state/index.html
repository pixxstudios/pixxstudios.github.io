<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Using useState hook with the previous state | Gagandeep Singh</title>
<meta name="keywords" content="reactjs, usestate" />
<meta name="description" content="Let&rsquo;s take a very basic use case of the useState() hook; updating the count variable on each click.
The code look perfectly fine and will work as expected in almost every time.
BUT the issue with this code is that setCount() doesn&rsquo;t guarantee that the previous count that it&rsquo;s going to use to either increment and decrement to get the next state will be the latest one.
To make sure that we always use the latest previous state for calculating the new state, we need to pass a callback function in the setCount rather than directly doing computation inside it.">
<meta name="author" content="Gagandeep Singh">
<link rel="canonical" href="https://pixxstudios.github.io/posts/use-state-with-previous-state/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.5b356452097f4f55796ea06a8d8cfa5508803dfd2a62e492988043baf23e21dc.css" integrity="sha256-WzVkUgl/T1V5bqBqjYz6VQiAPf0qYuSSmIBDuvI&#43;Idw=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://pixxstudios.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://pixxstudios.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://pixxstudios.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://pixxstudios.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://pixxstudios.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.84.2" />
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Using useState hook with the previous state" />
<meta property="og:description" content="Let&rsquo;s take a very basic use case of the useState() hook; updating the count variable on each click.
The code look perfectly fine and will work as expected in almost every time.
BUT the issue with this code is that setCount() doesn&rsquo;t guarantee that the previous count that it&rsquo;s going to use to either increment and decrement to get the next state will be the latest one.
To make sure that we always use the latest previous state for calculating the new state, we need to pass a callback function in the setCount rather than directly doing computation inside it." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://pixxstudios.github.io/posts/use-state-with-previous-state/" /><meta property="og:image" content="https://pixxstudios.github.io/papermod-cover.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-10-02T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2020-10-02T00:00:00&#43;00:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://pixxstudios.github.io/papermod-cover.png"/>

<meta name="twitter:title" content="Using useState hook with the previous state"/>
<meta name="twitter:description" content="Let&rsquo;s take a very basic use case of the useState() hook; updating the count variable on each click.
The code look perfectly fine and will work as expected in almost every time.
BUT the issue with this code is that setCount() doesn&rsquo;t guarantee that the previous count that it&rsquo;s going to use to either increment and decrement to get the next state will be the latest one.
To make sure that we always use the latest previous state for calculating the new state, we need to pass a callback function in the setCount rather than directly doing computation inside it."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://pixxstudios.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Using useState hook with the previous state",
      "item": "https://pixxstudios.github.io/posts/use-state-with-previous-state/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Using useState hook with the previous state",
  "name": "Using useState hook with the previous state",
  "description": "Let\u0026rsquo;s take a very basic use case of the useState() hook; updating the count variable on each click.\nThe code look perfectly fine and will work as expected in almost every time.\nBUT the issue with this code is that setCount() doesn\u0026rsquo;t guarantee that the previous count that it\u0026rsquo;s going to use to either increment and decrement to get the next state will be the latest one.\nTo make sure that we always use the latest previous state for calculating the new state, we need to pass a callback function in the setCount rather than directly doing computation inside it.",
  "keywords": [
    "reactjs", "usestate"
  ],
  "articleBody": "Let’s take a very basic use case of the useState() hook; updating the count variable on each click.\nThe code look perfectly fine and will work as expected in almost every time.\nBUT the issue with this code is that setCount() doesn’t guarantee that the previous count that it’s going to use to either increment and decrement to get the next state will be the latest one.\nTo make sure that we always use the latest previous state for calculating the new state, we need to pass a callback function in the setCount rather than directly doing computation inside it.\nThis way we can guarantee that we are always using the latest state value before using it.\n",
  "wordCount" : "117",
  "inLanguage": "en",
  "datePublished": "2020-10-02T00:00:00Z",
  "dateModified": "2020-10-02T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Gagandeep Singh"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://pixxstudios.github.io/posts/use-state-with-previous-state/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Gagandeep Singh",
    "logo": {
      "@type": "ImageObject",
      "url": "https://pixxstudios.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://pixxstudios.github.io/" accesskey="h" title="Gagandeep Singh (Alt + H)">Gagandeep Singh</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://pixxstudios.github.io/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://pixxstudios.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://pixxstudios.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://pixxstudios.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://pixxstudios.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      Using useState hook with the previous state
    </h1>
    <div class="post-meta">October 2, 2020&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Gagandeep Singh
</div>
  </header> 
  <div class="post-content"><p>Let&rsquo;s take a very basic use case of the useState() hook; updating the <strong>count</strong> variable on each click.</p>
<p><img loading="lazy" src="/images/carbon-2-1024x479.png" alt="usestate"  />
</p>
<p>The code look perfectly fine and will work as expected in almost every time.</p>
<p><em>BUT the issue with this code is that setCount() doesn&rsquo;t guarantee that the previous <strong>count</strong> that it&rsquo;s going to use to either increment and decrement to get the next state will be the latest one.</em></p>
<p>To make sure that we always use the latest previous state for calculating the new state, we need to pass a callback function in the setCount rather than directly doing computation inside it.</p>
<p><img loading="lazy" src="/images/carbon-3-1024x377.png" alt="usestate"  />
</p>
<p>This way we can guarantee that we are always using the latest state value before using it.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://pixxstudios.github.io/tags/reactjs/">reactjs</a></li>
      <li><a href="https://pixxstudios.github.io/tags/usestate/">usestate</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://pixxstudios.github.io/posts/docker-commands/">
    <span class="title">« Prev Page</span>
    <br>
    <span>Docker - useful commands</span>
  </a>
  <a class="next" href="https://pixxstudios.github.io/posts/browser-storage/">
    <span class="title">Next Page »</span>
    <br>
    <span>Browser storage (overview)</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="https://pixxstudios.github.io/">Gagandeep Singh</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
